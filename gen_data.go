// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// This file generates data.gen.go.
// It embeds the text of all the licenses in the subdirectory "licenses"
// and constructs the data structures to represent them.
// Run by a "go:generate" comment in license.go.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var outFile = flag.String("o", "data.gen.go", "`file` to write")

func main() {
	log.SetFlags(0)
	log.SetPrefix("gen: ")
	flag.Parse()

	all, err := filepath.Glob(filepath.Join("licenses", "*"))
	if err != nil {
		log.Fatal(err)
	}
	var files, filesLRE []string
	for _, file := range all {
		name := filepath.Base(file)
		if strings.HasPrefix(name, "README") || strings.HasSuffix(name, ".go") {
			continue
		}
		if info, err := os.Stat(file); err == nil && info.IsDir() {
			continue
		}
		if strings.HasSuffix(name, ".lre") {
			filesLRE = append(filesLRE, file)
		} else {
			files = append(files, file)
		}
	}
	if len(files) == 0 {
		log.Fatal("no license files")
	}

	code := outputTemplate
	out := new(bytes.Buffer)
	for _, file := range files {
		fmt.Fprintf(out, "\t\t{Name: %q, Text: %v},\n", filepath.Base(file), varName(file))
	}
	code = strings.Replace(code, "FILES_LIST", out.String(), -1)

	out.Reset()
	for _, file := range filesLRE {
		name := filepath.Base(file)
		name = name[:len(name)-len(filepath.Ext(name))]
		fmt.Fprintf(out, "\t\t{Name: %q, Text: %v},\n", name, varName(file))
	}
	code = strings.Replace(code, "FILES_LRE_LIST", out.String(), -1)

	out.Reset()
	for _, file := range append(files, filesLRE...) {
		data, err := ioutil.ReadFile(file)
		if err != nil {
			log.Fatal(err)
		}
		fmt.Fprintf(out, "const %s = `%s`\n",
			varName(file),
			bytes.ReplaceAll(data, []byte("`"), []byte("` + \"`\" + `")))
	}
	code += out.String()

	src, err := format.Source([]byte(code))
	if err != nil {
		fd, err1 := ioutil.TempFile("", "license-data")
		if err1 == nil {
			_, err1 = fd.Write([]byte(code))
			if err1 == nil {
				log.Fatalf("parsing output (written to %s): %v", fd.Name(), err)
			}
			fd.Close()
		}
		log.Fatal("parsing output:", err)
	}
	err = ioutil.WriteFile(*outFile, src, 0644)
	if err != nil {
		log.Fatal(err)
	}
}

// varName returns the basename of the file, sanitized for use as a variable name,
// and given the prefix "license_".
func varName(file string) string {
	mapping := func(r rune) rune {
		if r == '-' || r == '.' || r == '+' {
			return '_'
		}
		return r
	}
	return "license_" + strings.Map(mapping, filepath.Base(file))
}

const outputTemplate = `
// Code generated by gen_data.go; DO NOT EDIT.

package licensecheck

func init() {
	files := []License{
		FILES_LIST
	}
	builtinList = append(files, builtinURLs...)
	builtin = New(BuiltinLicenses())

	filesLRE := []License{
		FILES_LRE_LIST
	}
	builtinListLRE = filesLRE // TODO URLs
	s, err := NewScanner(filesLRE) // TODO BuiltinScannerLicenses
	if err != nil {
		panic(err)
	}
	builtinScanner = s
}
`
